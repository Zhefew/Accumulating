给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

示例 1：
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
示例 2：

输入：lists = []
输出：[]
示例 3：

输入：lists = [[]]
输出：[]

practice
```

```
标准答案
```
#include <bits/stdc++.h>

using namespace std;

// 链表节点定义
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) return nullptr;  // 处理空输入
        ListNode* dummy = new ListNode(-1); // 创建虚拟头节点简化操作
        ListNode* p = dummy;
        
        // 定义最小堆比较规则：a->val > b->val时，a的优先级更低
        auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);
        
        // 初始将所有链表的头节点入堆
        for (ListNode* head : lists) {
            if (head) pq.push(head); // 跳过空链表
        }
        
        // 开始合并过程
        while (!pq.empty()) {
            ListNode* node = pq.top(); // 取出当前最小节点
            pq.pop();
            p->next = node;  // 将节点连接到结果链表
            p = p->next;     // 移动指针
            if (node->next) pq.push(node->next); // 将下一个节点入堆
        }
        return dummy->next; // 返回合并后的头节点
    }
};

// 根据输入创建链表
ListNode* createList(const vector<int>& nums) {
    if (nums.empty()) return nullptr;
    ListNode* head = new ListNode(nums[0]);
    ListNode* cur = head;
    for (int i = 1; i < nums.size(); ++i) {
        cur->next = new ListNode(nums[i]);
        cur = cur->next;
    }
    return head;
}

// 打印链表
void printList(ListNode* head) {
    while (head) {
        cout << head->val << " ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    // 读取输入
    int k;
    cin >> k;
    vector<ListNode*> lists;
    for (int i = 0; i < k; ++i) {
        vector<int> nums;
        int num;
        while (cin >> num) {
            nums.push_back(num);
            if (cin.get() == '\n') break; // 读到换行符结束
        }
        lists.push_back(createList(nums));
    }
    
    // 合并并输出
    Solution solution;
    ListNode* result = solution.mergeKLists(lists);
    printList(result);
    
    return 0;
}

```