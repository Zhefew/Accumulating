1.将数组变成逻辑环形数组
```
	#include <iostream>
	#include <vector>
	using namespace std;
	
	// 长度为 5 的数组
	vector<int> arr = {1, 2, 3, 4, 5};
	int i = 0;
	// 模拟环形数组，这个循环永远不会结束
	while (i < arr.size()) {
	    cout << arr[i] << endl;
	    i = (i + 1) % arr.size();
	}
```
2.构建真环形数组
```
	#include <iostream>
	#include <stdexcept>
	#include <ostream>
	
	template<typename T>
	class CycleArray {
	    std::unique_ptr<T[]> arr;
	    int start;
	    int end;
	    int count;
	    int size;
	
	    // 自动扩缩容辅助函数
	    void resize(int newSize) {
	        // 创建新的数组
	        std::unique_ptr<T[]> newArr = std::make_unique<T[]>(newSize);
	        // 将旧数组的元素复制到新数组中
	        for (int i = 0; i < count; ++i) {
	            newArr[i] = arr[(start + i) % size];
	        }
	        arr = std::move(newArr);
	        // 重置 start 和 end 指针
	        start = 0;
	        end = count;
	        size = newSize;
	    }
	
	public:
	    CycleArray() : CycleArray(1) {
	    }
	
	    explicit CycleArray(int size) : start(0), end(0), count(0), size(size) {
	        arr = std::make_unique<T[]>(size);
	    }


	    // 在数组头部添加元素，时间复杂度 O(1)
	    void addFirst(const T &val) {
	        // 当数组满时，扩容为原来的两倍
	        if (isFull()) {
	            resize(size * 2);
	        }
	        // 因为 start 是闭区间，所以先左移，再赋值
	        start = (start - 1 + size) % size;
	        arr[start] = val;
	        count++;
	    }
	
	    // 删除数组头部元素，时间复杂度 O(1)
	    void removeFirst() {
	        if (isEmpty()) {
	            throw std::runtime_error("Array is empty");
	        }
	        // 因为 start 是闭区间，所以先赋值，再右移
	        arr[start] = T();
	        start = (start + 1) % size;
	        count--;
	        // 如果数组元素数量减少到原大小的四分之一，则减小数组大小为一半
	        if (count > 0 && count == size / 4) {
	            resize(size / 2);
	        }
	    }
	
	    // 在数组尾部添加元素，时间复杂度 O(1)
	    void addLast(const T &val) {
	        if (isFull()) {
	            resize(size * 2);
	        }
	        // 因为 end 是开区间，所以是先赋值，再右移
	        arr[end] = val;
	        end = (end + 1) % size;
	        count++;
	    }
	
	    // 删除数组尾部元素，时间复杂度 O(1)
	    void removeLast() {
	        if (isEmpty()) {
	            throw std::runtime_error("Array is empty");
	        }
	        // 因为 end 是开区间，所以先左移，再赋值
	        end = (end - 1 + size) % size;
	        arr[end] = T();
	        count--;
	        // 缩容
	        if (count > 0 && count == size / 4) {
	            resize(size / 2);
	        }
	    }
	
	    // 获取数组头部元素，时间复杂度 O(1)
	    T getFirst() const {
	        if (isEmpty()) {
	            throw std::runtime_error("Array is empty");
	        }
	        return arr[start];
	    }
	
	    // 获取数组尾部元素，时间复杂度 O(1)
	    T getLast() const {
	        if (isEmpty()) {
	            throw std::runtime_error("Array is empty");
	        }
	        // end 是开区间，指向的是下一个元素的位置，所以要减 1
	        return arr[(end - 1 + size) % size];
	    }
	
	    bool isFull() const {
	        return count == size;
	    }
	
	    int getSize() const {
	        return count;
	    }
	
	    bool isEmpty() const {
	        return count == 0;
	    }
	};
```