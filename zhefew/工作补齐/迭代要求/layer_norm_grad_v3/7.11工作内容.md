确定需要修改的文件
```
已完成
ops/built-in/op_tiling/runtime/layer_norm_grad_v3/layer_norm_grad_v3_tiling.h
//  在相关的 TilingData 结构体
LayerNormGradV3TilingDataRecompute,
LayerNormGradV3TilingDataGroupedReduceBigM, 
LayerNormGradV3TilingDataGroupedReduceBigN 中，新增两个布尔字段，
run_dx_kernel和run_gamma_beta_kernel
用于在 apt.cpp 层面控制子核函数的调用。
```

```
ops/built-in/op_tiling/runtime/layer_norm_grad_v3/layer_norm_grad_v3_tiling.cc
// 
LayerNormGradV3RecomputeTiling::DoOpTiling()
LayerNormGradV3GroupedReduceBigMTiling::DoOpTiling()
LayerNormGradV3GroupedReduceBigNTiling::DoOpTiling()
// 获取 Operator 对象 通过 context_->GetOperator() 或 context_->GetOpParam()
	const ge::Operator* op = context_->GetOperator();
    OPS_CHECK_NULL_WITH_CONTEXT(context_, op);
    
从 Operator 获取 output_mask 属性值（std::vector<bool>）。
   std::vector<bool> output_mask_attr;
    if (!op->GetAttr("output_mask", output_mask_attr)) {
        
将 output_mask 属性值填充到 td_.output_mask[3] 中。
    td_.set_output_mask_0(output_mask_attr[0]); // 假设 TILING_DATA_FIELD_DEF 会生成 set_xxx(value) 方法
    td_.set_output_mask_1(output_mask_attr[1]);
    td_.set_output_mask_2(output_mask_attr[2]);

根据 td_.output_mask 的值，计算并设置 td_.run_dx_kernel 和 td_.run_gamma_beta_kernel
    td_.set_run_dx_kernel(output_mask_attr[0]); // 如果 pd_x 需要输出，则运行 dx 核
    td_.set_run_gamma_beta_kernel(output_mask_attr[1] || output_mask_attr[2]); // 如果 pd_gamma 或 pd_beta 任一需要输出，则运行 gamma/beta 核

 // 兼容性处理：如果属性不存在，则默认都为 true
        OP_LOGW(GetNodeName(), "Attribute 'output_mask' not found, defaulting to [true, true, true].");
        output_mask_attr = {true, true, true};
    }

    // 确保 output_mask_attr 长度正确（至少3个元素）
    if (output_mask_attr.size() < 3) {
        OP_LOGE(GetNodeName(), "Attribute 'output_mask' has less than 3 elements. Defaulting missing elements to true.");
        while (output_mask_attr.size() < 3) {
            output_mask_attr.push_back(true); // 补齐缺失的元素，通常默认是true
        }
    }

    // 4. 填充 output_mask 到 TilingData (td_)

    // 5. 派生并设置 run_dx_kernel 和 run_gamma_beta_kernel




```

```
ops/norm/layer_norm_grad_v3/op_kernel/layer_norm_grad_v3_apt.cpp
// (好像是现成的)拆分 Invoke 函数： 将每个 InvokeLayerNormGradV3XxxImpl 函数拆分为两个独立的函数：一个用于 GammaBeta 的计算，另一个用于 Backward(pd_x) 的计算
// 修改layer_norm_grad_v3 全局核函数：

- 在每个 TILING_KEY_IS 分支内部，获取对应的 tiling_data 结构体。
- 使用 if (tiling_data.run_gamma_beta_kernel) 条件判断来调用 GammaBetaSubKernel。
- 使用 `if (tiling_data.run_dx_kernel)` 条件判断来调用 BackwardSubKernel。

```

```
ops/norm/layer_norm_grad_v3/op_kernel/v35/layer_norm_grad_v3_recompute_backward_impl.h
// 修改 ProcessX 方法：
输入张量 (dy_, x_, gamma_) 的 CopyIn 和 DeQue 操作必须无条件执行。
核心修改： 将 ComputeDx 的调用以及后续的 dx_ 相关的类型转换、EnQue、DeQue 和 CopyOut 操作包裹在 if (td_->output_mask[0]) 条件中。
确保所有输入张量的 FreeTensor 操作在 ProcessX 函数的末尾无条件执行。
```

```
ops/norm/layer_norm_grad_v3/op_kernel/v35/layer_norm_grad_v3_recompute_gamma_beta_impl.h
修改 Process 方法或其子函数（通常是 Epilogue 或执行 CopyOut 的函数）：
计算逻辑（如 ComputeGamma）应无条件执行。
核心修改： 在实际执行 CopyOut 到 pdGammaOutTensorGM 和 pdBetaOutTensorGM 的地方，分别添加 if (td_->output_mask[1]) 和 if (td_->output_mask[2]) 条件。
```

```
其他 _impl.h 文件 (例如 layer_norm_grad_v3_grouped_reduce_big_m_impl.h, layer_norm_grad_v3_grouped_reduce_big_n_impl.h 及其对应的 gamma_beta 版本)

对这些文件进行与recompute_backward_impl.h 和 recompute_gamma_beta_impl.h 完全相同逻辑的修改。
Init 中 GlobalTensor 设置无条件。
Process 中子计算函数调用无条件。
在实际 CopyOut 的地方添加 if (td_->output_mask[index]) 条件。
```




